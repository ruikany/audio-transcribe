<!doctype html>
<html>
  <head>
    <title>Real-Time STT with Flask</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 2em;
      }
      #transcript {
        white-space: pre-wrap;
        padding: 1em;
        background: #f4f4f4;
        border-radius: 5px;
      }
      #status {
        color: #555;
      }
    </style>
  </head>
  <body>
    <h1>Real-Time Transcription with Flask & RealtimeSTT</h1>
    <button id="recBtn">Start Recording</button>
    <p id="status">Status: Not Connected</p>
    <h3>Transcription:</h3>
    <div id="transcript"></div>

    <script>
      const recBtn = document.getElementById("recBtn");
      const transcriptEl = document.getElementById("transcript");
      const statusEl = document.getElementById("status");

      let ws;
      let audioContext;
      let audioProcessor;
      let mediaStream;

      let recording = false;

      // --- WebSocket Handling ---
      function connectWebSocket() {
        const wsUrl = `ws://${window.location.host}/mic`;
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          statusEl.textContent = "Status: Connected. Ready to record.";
          recBtn.disabled = false;
        };

        ws.onmessage = (event) => {
          // Server sent us a new transcription
          const message = event.data;
          console.log("Received message:", message); // DEBUG

          if (message.startsWith("FINAL:")) {
            const newText = message.substring(6); // Get text after "FINAL: "
            transcriptEl.textContent = newText; // Replace whole content
            statusEl.textContent = "Status: Connected. Ready to record.";
          } else if (message.startsWith("INTERIM:")) {
            const interimText = message.substring(8); // Get text after "INTERIM: "
            statusEl.textContent = "Processing: " + interimText;
          }
        };

        ws.onclose = () => {
          statusEl.textContent = "Status: Disconnected. Refresh to retry.";
          stopRecording();
        };

        ws.onerror = (err) => {
          console.error("WebSocket Error:", err);
          statusEl.textContent = "Status: WebSocket Error.";
        };
      }

      // --- Audio Processing ---
      async function startRecording() {
        if (recording) return;
        recording = true;
        recBtn.textContent = "Stop Recording";

        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(mediaStream);
          audioProcessor = audioContext.createScriptProcessor(1024, 1, 1);

          const nativeSampleRate = audioContext.sampleRate;

          audioProcessor.onaudioprocess = (e) => {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            // Get raw input data
            const float32Data = e.inputBuffer.getChannelData(0);

            // Resample
            const resampledData = resample(
              float32Data,
              nativeSampleRate,
              16000,
            );

            // Convert the *RESAMPLED DATA* to 16-bit PCM (Int16)
            const pcmData = new Int16Array(resampledData.length);
            for (let i = 0; i < resampledData.length; i++) {
              let s = Math.max(-1, Math.min(1, resampledData[i])); // Use resampledData
              pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
            }

            // --- ⬇️ DEBUG CODE (MOVED TO CORRECT LOCATION) ⬇️ ---
            let maxVolume = 0;
            for (let i = 0; i < float32Data.length; i++) {
              // Check original data for volume
              maxVolume = Math.max(maxVolume, Math.abs(float32Data[i]));
            }
            console.log(
              `Sending ${pcmData.buffer.byteLength} bytes... Input Max Volume: ${maxVolume.toFixed(4)}`,
            );
            // --- ⬆️ END OF DEBUG CODE ⬆️ ---

            ws.send(pcmData.buffer);
          };

          source.connect(audioProcessor);
          audioProcessor.connect(audioContext.destination);
        } catch (e) {
          console.error("Error starting audio:", e);
          statusEl.textContent = "Error: Could not access microphone.";
          recording = false;
          recBtn.textContent = "Start Recording";
        }
      }

      function stopRecording() {
        if (!recording) return;
        recording = false;
        recBtn.textContent = "Start Recording";

        if (audioProcessor) {
          audioProcessor.disconnect();
          audioProcessor = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        if (mediaStream) {
          mediaStream.getTracks().forEach((track) => track.stop());
          mediaStream = null;
        }
      }

      // --- Init ---
      recBtn.onclick = () => {
        recording ? stopRecording() : startRecording();
      };
      recBtn.disabled = true;
      connectWebSocket();

      // --- Resample Helper Function ---
      function resample(buffer, fromSampleRate, toSampleRate) {
        if (fromSampleRate === toSampleRate) {
          return buffer;
        }
        const ratio = fromSampleRate / toSampleRate;
        const newLength = Math.floor(buffer.length / ratio);
        const result = new Float32Array(newLength);

        for (let i = 0; i < newLength; i++) {
          const floatIndex = i * ratio;
          const index = Math.floor(floatIndex);
          const fraction = floatIndex - index;

          const p0 = buffer[index];
          const p1 = buffer[index + 1];

          if (p1 === undefined) {
            result[i] = p0;
          } else {
            result[i] = p0 + (p1 - p0) * fraction;
          }
        }
        return result;
      }
    </script>
  </body>
</html>
